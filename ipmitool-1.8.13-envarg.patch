diff -up ./doc/ipmitool.1.envarg ./doc/ipmitool.1
--- ./doc/ipmitool.1.envarg	2014-09-29 15:50:51.612848983 +0200
+++ ./doc/ipmitool.1	2014-09-29 15:51:02.906864127 +0200
@@ -138,7 +138,8 @@ Use supplied Kg key for IPMIv2.0 authent
 use any Kg key.
 .TP 
 \fB\-K\fR
-Read Kg key from IPMI_KGKEY environment variable.
+Read Kg key from IPMITOOL_KGKEY or IPMI_KGKEY environment variable.
+IPMITOOL_KGKEY takes precedence.
 .TP 
 \fB\-l\fR <\fIlun\fP>
 Set destination lun for raw commands.
@@ -237,6 +238,9 @@ Change Size of Communication Channel. (O
 If no password method is specified then ipmitool will prompt the
 user for a password. If no password is entered at the prompt,
 the remote server password will default to NULL.
+
+All the above options may be specified using environment variable.
+Either IPMITOOL_OPTS or IPMI_OPTS. IPMITOOL_OPTS takes precedence.
 .SH "SECURITY"
 There are several security issues be be considered before enabling the
 IPMI LAN interface. A remote station has the ability to control a system's power 
diff -up ./lib/ipmi_main.c.envarg ./lib/ipmi_main.c
--- ./lib/ipmi_main.c.envarg	2014-09-29 15:50:38.527811367 +0200
+++ ./lib/ipmi_main.c	2014-09-29 15:58:38.540139925 +0200
@@ -325,12 +325,23 @@ ipmi_main(int argc, char ** argv,
 	char sol_escape_char = SOL_ESCAPE_CHARACTER_DEFAULT;
 	char * devfile  = NULL;
 
+	int cnt = argc;
+	char **arg = argv;
+	int argecnt = 0;
+	char **arge = NULL;
+	char **narge = NULL;
+	char *argestr = NULL;
+	int voptind;
+
 	/* save program name */
 	progname = strrchr(argv[0], '/');
 	progname = ((progname == NULL) ? argv[0] : progname+1);
 	signal(SIGINT, ipmi_catch_sigint);
 
-	while ((argflag = getopt(argc, (char **)argv, OPTION_STRING)) != -1)
+	do
+	{
+
+	while ((argflag = getopt(cnt, arg, OPTION_STRING)) != -1)
 	{
 		switch (argflag) {
 		case 'I':
@@ -478,7 +489,7 @@ ipmi_main(int argc, char ** argv,
 					goto out_free;
 				}
 				strncpy(kgkey, tmp_env, IPMI_KG_BUFFER_SIZE);
-            } else if ((tmp_env = getenv("IPMI_KGKEY"))) {
+			} else if ((tmp_env = getenv("IPMI_KGKEY"))) {
 				if (kgkey) {
 					free(kgkey);
 					kgkey = NULL;
@@ -738,6 +749,48 @@ ipmi_main(int argc, char ** argv,
 	}
 
 
+		if (arge == NULL) {
+			arge = malloc(sizeof(char*));
+			if (arge == NULL) {
+				lprintf(LOG_ERR, "Could not allocate memory for arguments");
+				rc = -1;
+				goto out_free;
+			}
+			arge[0] = strdup("ipmitool-env");
+			argecnt = 0;
+			if (!(argestr = getenv("IPMITOOL_OPTS"))) {
+				argestr = getenv("IPMI_OPTS");
+			}
+			if (argestr != NULL) {
+				char *tok = NULL;
+				while (tok = strtok_r(argestr, " ", &argestr)) {
+					narge = realloc(arge, sizeof(char*)*(2+argecnt));
+					if (narge == NULL) {
+						lprintf(LOG_ERR, "Could not reallocate memory for arguments");
+						rc = -1;
+						goto out_free;
+					} else {
+						arge = narge;
+						argecnt++;
+						arge[argecnt] = tok;
+					}
+				}
+				arg = arge;
+				cnt = 1+argecnt;
+				voptind = optind;
+				optind = 0;
+			} else {
+				/* no env cont skip */
+				cnt = 0;
+				voptind = optind;
+			}
+		} else {
+			/* env finished */
+			cnt = 0;
+			optind = voptind;
+		}
+	} while (arge != NULL && cnt >0);
+ 
 	/* check for command before doing anything */
 	if (argc-optind > 0 &&
 		strncmp(argv[optind], "help", 4) == 0) {
