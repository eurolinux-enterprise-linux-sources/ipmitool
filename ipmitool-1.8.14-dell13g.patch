From a0c9f3897bbc4a6b02534d9ef0d5e11af9a2672c Mon Sep 17 00:00:00 2001
Date: Thu, 5 Jun 2014 16:55:44 +0530
Subject: [PATCH 1/1]Dell Adding support for 13G(newer generation) Dell PowerEdge
 servers


Signed-off-by: SriniG <srinivas_g_gowda@dell.com>
---
 include/ipmitool/ipmi_delloem.h |  4 +++
 lib/ipmi_delloem.c              | 77 ++++++++++++++++++++++++-----------------
 2 files changed, 50 insertions(+), 31 deletions(-)

diff --git a/include/ipmitool/ipmi_delloem.h b/include/ipmitool/ipmi_delloem.h
index 88f5c22..bae9510 100644
--- a/include/ipmitool/ipmi_delloem.h
+++ b/include/ipmitool/ipmi_delloem.h
@@ -72,6 +72,7 @@ POSSIBILITY OF SUCH DAMAGE.
 
 #define	IDRAC_11G					1
 #define	IDRAC_12G					2
+#define	IDRAC_13G					3
 // Return Error code for license
 #define	LICENSE_NOT_SUPPORTED		0x6F
 #define	VFL_NOT_LICENSED			0x33
@@ -184,6 +185,9 @@ typedef struct _lcd_mode
 #define IMC_IDRAC_12G_MONOLITHIC 	(uint8_t) (0x10)
 #define IMC_IDRAC_12G_MODULAR 		(uint8_t) (0x11)
 
+#define IMC_IDRAC_13G_MONOLITHIC 	(uint8_t) (0x20)
+#define IMC_IDRAC_13G_MODULAR 		(uint8_t) (0x21)
+#define IMC_IDRAC_13G_DCS	 		(uint8_t) (0x22)
 
 
 typedef struct
diff --git a/lib/ipmi_delloem.c b/lib/ipmi_delloem.c
index e190cd4..847f8d9 100644
--- a/lib/ipmi_delloem.c
+++ b/lib/ipmi_delloem.c
@@ -358,7 +358,7 @@ ipmi_delloem_lcd_main(struct ipmi_intf * intf, int argc, char ** argv)
 		lprintf(LOG_ERR, "lcd is not supported on this system.");
 		return -1;
 	} else if (strncmp(argv[current_arg], "info\0", 5) == 0) {
-		if ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G)) {
+		if ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G) || (iDRAC_FLAG == IDRAC_13G)) {
 			rc = ipmi_lcd_get_info_wh(intf);
 		} else {
 			rc = ipmi_lcd_get_info(intf);
@@ -392,7 +392,7 @@ ipmi_delloem_lcd_main(struct ipmi_intf * intf, int argc, char ** argv)
 			}
 		}
 		if ((strncmp(argv[current_arg], "mode\0", 5) == 0)
-				&& ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G))) {
+				&& ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G) || (iDRAC_FLAG == IDRAC_13G))) {
 			current_arg++;
 			if (argc <= current_arg) {
 				ipmi_lcd_usage();
@@ -446,7 +446,7 @@ ipmi_delloem_lcd_main(struct ipmi_intf * intf, int argc, char ** argv)
 				ipmi_lcd_usage();
 			}
 		} else if ((strncmp(argv[current_arg], "lcdqualifier\0", 13) == 0)
-				&& ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G))) {
+				&& ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G) || (iDRAC_FLAG == IDRAC_13G))) {
 			current_arg++;
 			if (argc <= current_arg) {
 				ipmi_lcd_usage();
@@ -470,7 +470,7 @@ ipmi_delloem_lcd_main(struct ipmi_intf * intf, int argc, char ** argv)
 				ipmi_lcd_usage();
 			}
 		} else if ((strncmp(argv[current_arg], "errordisplay\0", 13) == 0)
-				&& ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G))) {
+				&& ((iDRAC_FLAG==IDRAC_11G) || (iDRAC_FLAG==IDRAC_12G) || (iDRAC_FLAG == IDRAC_13G))) {
 			current_arg++;
 			if (argc <= current_arg) {
 				ipmi_lcd_usage();
@@ -644,6 +644,10 @@ ipmi_idracvalidator_command(struct ipmi_intf * intf)
 	} else if((IMC_IDRAC_12G_MONOLITHIC == data[10])
 			|| (IMC_IDRAC_12G_MODULAR == data[10])) {
 		iDRAC_FLAG = IDRAC_12G;
+	} else if( (IMC_IDRAC_13G_MONOLITHIC == data[10]) 
+			|| (IMC_IDRAC_13G_MODULAR == data[10]) 
+			|| (IMC_IDRAC_13G_DCS == data[10]) ) {
+		iDRAC_FLAG=IDRAC_13G;    
 	} else {
 		iDRAC_FLAG = 0;
 	}
@@ -1394,7 +1398,7 @@ ipmi_lcd_usage(void)
 	lprintf(LOG_NOTICE,
 "");
 	lprintf(LOG_NOTICE,
-"iDRAC 11g or iDRAC 12g:");
+"iDRAC 11g or iDRAC 12g or  iDRAC 13g :");
 	lprintf(LOG_NOTICE,
 "   lcd set {mode}|{lcdqualifier}|{errordisplay}");
 	lprintf(LOG_NOTICE,
@@ -1561,7 +1565,9 @@ ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf* intf,uint8_t NicNum)
 		return -1;
 	}
 	if ((IMC_IDRAC_12G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)) {
+			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)
+			|| (IMC_IDRAC_13G_MODULAR == IMC_Type) 
+			|| (IMC_IDRAC_13G_MONOLITHIC== IMC_Type)) {
 		/* Get the Chasiss Assigned MAC Addresss for 12g Only */
 		memcpy(VirtualMacAddress, ((rsp->data) + 1), MACADDRESSLENGH);
 		for (i = 0; i < MACADDRESSLENGH; i++) {
@@ -1599,6 +1605,9 @@ ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf* intf,uint8_t NicNum)
 	} else if ((IMC_IDRAC_12G_MODULAR == IMC_Type)
 			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)) {
 		printf("\niDRAC7 MAC Address ");
+	} else if ((IMC_IDRAC_13G_MODULAR == IMC_Type) 
+			|| (IMC_IDRAC_13G_MONOLITHIC== IMC_Type))	 {
+			printf ("\niDRAC8 MAC Address ");		
 	} else if ((IMC_MASER_LITE_BMC== IMC_Type)
 			|| (IMC_MASER_LITE_NU== IMC_Type)) {
 		printf("\nBMC MAC Address ");
@@ -1668,6 +1677,9 @@ ipmi_macinfo_drac_idrac_mac(struct ipmi_intf* intf,uint8_t NicNum)
 	} else if ((IMC_IDRAC_12G_MODULAR == IMC_Type)
 			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)) {
 		printf("\niDRAC7 MAC Address ");
+	} else if ((IMC_IDRAC_13G_MODULAR == IMC_Type) 
+			|| (IMC_IDRAC_13G_MONOLITHIC== IMC_Type))	 {
+			printf ("\niDRAC8 MAC Address ");				
 	} else if ((IMC_MASER_LITE_BMC== IMC_Type)
 			|| (IMC_MASER_LITE_NU== IMC_Type)) {
 		printf("\n\rBMC MAC Address ");
@@ -1879,6 +1891,8 @@ ipmi_macinfo(struct ipmi_intf* intf, uint8_t NicNum)
 				|| IMC_IDRAC_11G_MONOLITHIC == IMC_Type)
 			|| (IMC_IDRAC_12G_MODULAR == IMC_Type
 				|| IMC_IDRAC_12G_MONOLITHIC == IMC_Type)
+			|| (IMC_IDRAC_13G_MODULAR == IMC_Type
+				|| IMC_IDRAC_13G_MONOLITHIC == IMC_Type)
 			|| (IMC_MASER_LITE_NU == IMC_Type || IMC_MASER_LITE_BMC== IMC_Type)) {
 		return ipmi_macinfo_11g(intf,NicNum);
 	} else {
@@ -1946,7 +1960,7 @@ ipmi_delloem_lan_main(struct ipmi_intf * intf, int argc, char ** argv)
 			ipmi_lan_usage();
 			return -1;
 		}
-		if (iDRAC_FLAG == IDRAC_12G) {
+		if ((iDRAC_FLAG == IDRAC_12G) || (iDRAC_FLAG == IDRAC_13G))  {
 			nic_selection = get_nic_selection_mode_12g(intf, current_arg, argv,
 					nic_set);
 			if (INVALID == nic_selection) {
@@ -2063,7 +2077,7 @@ get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
 	}
 	if (argv[current_arg] != NULL
 			&& strncmp(argv[current_arg], "lom1\0", 5) == 0) {
-		if (IMC_IDRAC_12G_MODULAR == IMC_Type) {
+		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
 			return INVAILD_SHARED_MODE;
 		}
 		if (failover) {
@@ -2082,7 +2096,7 @@ get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
 		return 0;
 	} else if (argv[current_arg] != NULL
 			&& strncmp(argv[current_arg], "lom2\0", 5) == 0) {
-		if (IMC_IDRAC_12G_MODULAR == IMC_Type) {
+		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
 			return INVAILD_SHARED_MODE;
 		}
 		if (failover) {
@@ -2101,7 +2115,7 @@ get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
 		return 0;
 	} else if (argv[current_arg] != NULL
 			&& strncmp(argv[current_arg], "lom3\0", 5) == 0) {
-		if (IMC_IDRAC_12G_MODULAR == IMC_Type) {
+		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
 			return INVAILD_SHARED_MODE;
 		}
 		if (failover) {
@@ -2120,7 +2134,7 @@ get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
 		return 0;
 	} else if (argv[current_arg] != NULL
 			&& strncmp(argv[current_arg], "lom4\0", 5) == 0) {
-		if (IMC_IDRAC_12G_MODULAR == IMC_Type) {
+		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
 			return INVAILD_SHARED_MODE;
 		}
 		if (failover) {
@@ -2139,7 +2153,7 @@ get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
 		return 0;
 	} else if (failover && argv[current_arg] != NULL
 			&& strncmp(argv[current_arg], "none\0", 5) == 0) {
-		if (IMC_IDRAC_12G_MODULAR == IMC_Type) {
+		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type) ) {
 			return INVAILD_SHARED_MODE;
 		}
 		if (failover) {
@@ -2159,7 +2173,7 @@ get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
 	current_arg++;
 	if (failover && argv[current_arg] != NULL
 			&& strncmp(argv[current_arg], "loms\0", 5) == 0) {
-		if (IMC_IDRAC_12G_MODULAR == IMC_Type) {
+		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
 			return INVAILD_SHARED_MODE;
 		}
 		if (nic_set[0] == 1) {
@@ -2242,7 +2256,8 @@ ipmi_lan_set_nic_selection_12g(struct ipmi_intf * intf, uint8_t * nic_selection)
 		lprintf(LOG_ERR, "Error in setting nic selection");
 		return -1;
 	} else if( (nic_selection[0] == 1)
-			&& ((iDRAC_FLAG == IDRAC_12G) && (rsp->ccode == LICENSE_NOT_SUPPORTED))) {
+			&& (( (iDRAC_FLAG == IDRAC_12G) || (iDRAC_FLAG == IDRAC_13G) )
+			&& (rsp->ccode == LICENSE_NOT_SUPPORTED))) {
 		/* Check license only for setting the dedicated nic. */
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
@@ -2297,7 +2312,7 @@ ipmi_lan_get_nic_selection(struct ipmi_intf * intf)
 	input_length = 0;
 	req.msg.netfn = DELL_OEM_NETFN;
 	req.msg.lun = 0;
-	if (iDRAC_FLAG == IDRAC_12G) {
+	if((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) {
 		req.msg.cmd = GET_NIC_SELECTION_12G_CMD;
 	} else {
 		req.msg.cmd = GET_NIC_SELECTION_CMD;
@@ -2314,7 +2329,7 @@ ipmi_lan_get_nic_selection(struct ipmi_intf * intf)
 		return -1;
 	}
 	nic_selection = rsp->data[0];
-	if (iDRAC_FLAG == IDRAC_12G) {
+	if((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) {
 		nic_selection_failover = rsp->data[1];
 		if ((nic_selection < 6) && (nic_selection > 0)
 				&& (nic_selection_failover < 7)) {
@@ -2413,7 +2428,7 @@ ipmi_lan_usage(void)
 	lprintf(LOG_NOTICE,
 "      sets the NIC Selection Mode :");
 	lprintf(LOG_NOTICE,
-"          on iDRAC12g :");
+"          on iDRAC12g OR iDRAC13g  :");
 	lprintf(LOG_NOTICE,
 "              dedicated, shared with lom1, shared with lom2,shared with lom3,shared");
 	lprintf(LOG_NOTICE,
@@ -2433,7 +2448,7 @@ ipmi_lan_usage(void)
 	lprintf(LOG_NOTICE,
 "   lan get ");
 	lprintf(LOG_NOTICE,
-"          on iDRAC12g :");
+"          on iDRAC12g or iDRAC13g  :");
 	lprintf(LOG_NOTICE,
 "              returns the current NIC Selection Mode (dedicated, shared with lom1, shared");
 	lprintf(LOG_NOTICE,
@@ -2662,7 +2677,7 @@ ipmi_get_power_capstatus_command(struct ipmi_intf * intf)
 	if (rsp == NULL) {
 		lprintf(LOG_ERR, "Error getting powercap status");
 		return -1;
-	} else if((iDRAC_FLAG == IDRAC_12G) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
+	} else if(((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1; /* Return Error as unlicensed */
@@ -2713,7 +2728,7 @@ ipmi_set_power_capstatus_command(struct ipmi_intf * intf, uint8_t val)
 	if (rsp == NULL) {
 		lprintf(LOG_ERR, "Error setting powercap status");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1; /* return unlicensed Error code */
@@ -2807,7 +2822,7 @@ ipmi_powermgmt(struct ipmi_intf * intf)
 		return -1;
 	}
 
-	if((iDRAC_FLAG == IDRAC_12G) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
+	if(((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -2910,7 +2925,7 @@ ipmi_powermgmt_clear(struct ipmi_intf * intf, uint8_t clearValue)
 	if (rsp == NULL) {
 		lprintf(LOG_ERR, "Error clearing power values.");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G)
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) )
 			&& (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
@@ -2988,7 +3003,7 @@ ipmi_get_power_headroom_command(struct ipmi_intf * intf,uint8_t unit)
 	if (rsp == NULL) {
 		lprintf(LOG_ERR, "Error getting power headroom status");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G)
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) )
 			&& (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
@@ -3122,7 +3137,7 @@ ipmi_get_instan_power_consmpt_data(struct ipmi_intf * intf,
 	if (rsp == NULL) {
 		lprintf(LOG_ERR, "Error getting instantaneous power consumption data .");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G)
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) )
 			&& (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
@@ -3215,7 +3230,7 @@ ipmi_get_avgpower_consmpt_history(struct ipmi_intf * intf,
 		lprintf(LOG_ERR,
 				"Error getting average power consumption history data.");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) &&  (rc == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) &&  (rc == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -3264,7 +3279,7 @@ ipmi_get_peakpower_consmpt_history(struct ipmi_intf * intf,
 	if (rc < 0) {
 		lprintf(LOG_ERR, "Error getting  peak power consumption history data.");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) && (rc == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rc == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -3321,7 +3336,7 @@ ipmi_get_minpower_consmpt_history(struct ipmi_intf * intf,
 	if (rc < 0) {
 		lprintf(LOG_ERR, "Error getting  peak power consumption history data .");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) &&  (rc == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) &&  (rc == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -3518,7 +3533,7 @@ ipmi_get_power_cap(struct ipmi_intf * intf, IPMI_POWER_CAP * ipmipowercap)
 	if (rc < 0) {
 		lprintf(LOG_ERR, "Error getting power cap.");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) && (rc == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rc == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -3618,7 +3633,7 @@ ipmi_set_power_cap(struct ipmi_intf * intf, int unit, int val)
 	if (rc < 0) {
 		lprintf(LOG_ERR, "Error getting power cap.");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) && (rc == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rc == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -3698,7 +3713,7 @@ ipmi_set_power_cap(struct ipmi_intf * intf, int unit, int val)
 	if (rc < 0) {
 		lprintf(LOG_ERR, "Error setting power cap");
 		return -1;
-	} else if ((iDRAC_FLAG == IDRAC_12G) && (rc == LICENSE_NOT_SUPPORTED)) {
+	} else if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) ) && (rc == LICENSE_NOT_SUPPORTED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
 		return -1;
@@ -3860,7 +3875,7 @@ ipmi_get_sd_card_info(struct ipmi_intf * intf) {
 
 	sdcardinfoblock = (IPMI_DELL_SDCARD_INFO *) (void *) rsp->data;
 
-	if ((iDRAC_FLAG == IDRAC_12G)
+	if (((iDRAC_FLAG == IDRAC_12G) ||(iDRAC_FLAG == IDRAC_13G) )
 			&& (sdcardinfoblock->vflashcompcode == VFL_NOT_LICENSED)) {
 		lprintf(LOG_ERR,
 				"FM001 : A required license is missing or expired");
-- 
1.8.1.2

