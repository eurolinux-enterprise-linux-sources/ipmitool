Backport from lan.c 1.67

 src/plugins/lan/lan.c |   71 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 62 insertions(+), 9 deletions(-)

diff -urNp a_ipmitool-1.8.11/src/plugins/lan/lan.c b_ipmitool-1.8.11/src/plugins/lan/lan.c
--- a_ipmitool-1.8.11/src/plugins/lan/lan.c	2012-10-06 19:03:22.000000000 +0900
+++ b_ipmitool-1.8.11/src/plugins/lan/lan.c	2012-10-06 19:02:21.000000000 +0900
@@ -105,7 +105,7 @@ struct ipmi_intf ipmi_lan_intf = {
 };
 
 static struct ipmi_rq_entry *
-ipmi_req_add_entry(struct ipmi_intf * intf, struct ipmi_rq * req)
+ipmi_req_add_entry(struct ipmi_intf * intf, struct ipmi_rq * req, uint8_t req_seq)
 {
 	struct ipmi_rq_entry * e;
 
@@ -119,6 +119,7 @@ ipmi_req_add_entry(struct ipmi_intf * in
 	memcpy(&e->req, req, sizeof(struct ipmi_rq));
 
 	e->intf = intf;
+	e->rq_seq = req_seq;
 
 	if (ipmi_req_entries == NULL)
 		ipmi_req_entries = e;
@@ -664,7 +665,7 @@ ipmi_lan_poll_recv(struct ipmi_intf * in
  * +--------------------+
  */
 static struct ipmi_rq_entry *
-ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
+ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req, int isRetry)
 {
 	struct rmcp_hdr rmcp = {
 		.ver		= RMCP_VERSION_1,
@@ -684,6 +685,9 @@ ipmi_lan_build_cmd(struct ipmi_intf * in
 	if (our_address == 0)
 		our_address = IPMI_BMC_SLAVE_ADDR;
 
+	if (isRetry == 0)
+		curr_seq++;
+
 	if (curr_seq >= 64)
 		curr_seq = 0;
 
@@ -707,7 +711,7 @@ ipmi_lan_build_cmd(struct ipmi_intf * in
 	{
 		// We dont have this request in the list so we can add it 
 		// to the list
-		entry = ipmi_req_add_entry(intf, req);
+		entry = ipmi_req_add_entry(intf, req, curr_seq);
 		if (entry == NULL)
 			return NULL;
 	}
@@ -774,14 +799,15 @@ ipmi_lan_build_cmd(struct ipmi_intf * in
 
 	if (!entry->bridging_level)
 		msg[len++] = IPMI_REMOTE_SWID;
-	else  /* Bridged message */
+	/* Bridged message */
+	else if (entry->bridging_level)
 		msg[len++] = intf->my_addr;
 
-	entry->rq_seq = curr_seq++;
+	entry->rq_seq = curr_seq;
 	msg[len++] = entry->rq_seq << 2;
 	msg[len++] = req->msg.cmd;
 
-	lprintf(LOG_DEBUG+1, ">> IPMI Request Session Header");
+	lprintf(LOG_DEBUG+1, ">> IPMI Request Session Header (level %d)", entry->bridging_level);
 	lprintf(LOG_DEBUG+1, ">>   Authtype   : %s",
 	       val2str(s->authtype, ipmi_authtype_session_vals));
 	lprintf(LOG_DEBUG+1, ">>   Sequence   : 0x%08lx", (long)s->in_seq);
@@ -851,6 +877,7 @@ ipmi_lan_send_cmd(struct ipmi_intf * int
 	struct ipmi_rq_entry * entry;
 	struct ipmi_rs * rsp = NULL;
 	int try = 0;
+	int isRetry = 0;
 
 	lprintf(LOG_DEBUG, "ipmi_lan_send_cmd:opened=[%d], open=[%d]",
 		intf->opened, intf->open);
@@ -865,7 +892,9 @@ ipmi_lan_send_cmd(struct ipmi_intf * int
 	}
 
 	for (;;) {
-		entry = ipmi_lan_build_cmd(intf, req);
+		isRetry = ( try > 0 ) ? 1 : 0;
+
+		entry = ipmi_lan_build_cmd(intf, req, isRetry);
 		if (entry == NULL) {
 			lprintf(LOG_ERR, "Aborting send command, unable to build");
 			return NULL;
@@ -898,6 +927,30 @@ ipmi_lan_send_cmd(struct ipmi_intf * int
 		}
 	}
 
+	// We need to cleanup the existing entries from the list. Because if we 
+	// keep it and then when we send the new command and if the response is for
+	// old command it still matches it and then returns success.
+	// This is the corner case where the remote controller responds very slowly.
+	//
+	// Example: We have to send command 23 and 2d.
+	// If we send command,seq as 23,10 and if we dont get any response it will 
+	// retry 4 times with 23,10 and then come out here and indicate that there is no
+	// reponse from the remote controller and will send the next command for 
+	// ie 2d,11. And if the BMC is slow to respond and returns 23,10 then it 
+	// will match it in the list and will take response of command 23 as response 
+	// for command 2d and return success. So ideally when retries are done and 
+	// are out of this function we should be clearing the list to be safe so that
+	// we dont match the old response with new request.
+	//          [23, 10] --> BMC
+	//          [23, 10] --> BMC
+	//          [23, 10] --> BMC
+	//          [23, 10] --> BMC
+	//          [2D, 11] --> BMC
+	//                   <-- [23, 10]
+	//  here if we maintain 23,10 in the list then it will get matched and consider
+	//  23 response as response for 2D.   
+	ipmi_req_clear_entries();
+
 	return rsp;
 }
 
